# main.py — micro:bit (MicroPython) ESN リアルタイム推論（完全オンライン / CSR + int8）+ メロディー
import microbit
import math
import music

MG2G = 1.0 / 1000.0

# ----------------------------
# tanh（MicroPythonにmath.tanhが無い場合があるため）
# ----------------------------
def _tanh(z):
    if z > 8.0:
        return 1.0
    if z < -8.0:
        return -1.0
    e = math.exp(2.0 * z)
    return (e - 1.0) / (e + 1.0)

# =========================================================
# ここにPC側で出力したモデル定数を貼り付け
# N,K,M, RES_ROW_PTR, RES_COL_IDX, RES_VAL_Q, RES_SCALE,
# IN_VAL_Q, IN_SCALE,
# W_OUT_Q, W_OUT_SCALE,
# B_RES_Q, B_RES_SCALE,
# LEAK, ADD_BIAS, MEAN, SCALE, CLASSES
# =========================================================
N = 64
K = 3
M = 3
RES_ROW_PTR = [0, 9, 15, 23, 30, 33, 37, 42, 50, 57, 63, 66, 69, 77, 85, 92, 101, 106, 111, 120, 127, 135, 150, 159, 165, 176, 183, 191, 196, 203, 209, 211, 215, 225, 234, 239, 245, 249, 257, 265, 275, 283, 290, 293, 297, 305, 318, 321, 329, 332, 332, 336, 341, 342, 351, 361, 370, 376, 383, 389, 391, 393, 402, 410, 416]
RES_COL_IDX = [1, 2, 8, 9, 18, 42, 48, 51, 53, 32, 36, 40, 46, 50, 54, 6, 8, 17, 26, 29, 36, 37, 43, 1, 21, 22, 45, 51, 58, 61, 11, 46, 58, 18, 26, 45, 59, 13, 28, 30, 35, 40, 22, 24, 29, 35, 42, 47, 50, 60, 1, 5, 7, 11, 34, 41, 57, 11, 24, 29, 37, 40, 44, 7, 38, 57, 32, 36, 48, 7, 9, 24, 33, 43, 55, 59, 62, 5, 7, 14, 24, 35, 51, 60, 61, 22, 23, 34, 52, 54, 57, 60, 6, 8, 18, 25, 33, 50, 58, 59, 60, 1, 13, 23, 31, 55, 8, 11, 18, 27, 55, 9, 16, 20, 22, 23, 33, 36, 47, 61, 4, 12, 26, 32, 35, 53, 54, 3, 13, 18, 21, 30, 31, 55, 56, 5, 12, 18, 21, 26, 27, 31, 33, 34, 38, 44, 55, 56, 58, 63, 12, 15, 18, 43, 54, 57, 58, 59, 61, 23, 32, 35, 47, 52, 54, 5, 8, 12, 19, 21, 26, 39, 40, 45, 47, 56, 1, 2, 8, 15, 41, 43, 45, 4, 11, 20, 25, 38, 44, 49, 55, 15, 19, 23, 53, 54, 1, 20, 24, 29, 37, 39, 59, 17, 25, 32, 37, 60, 62, 5, 10, 12, 29, 45, 49, 6, 7, 10, 22, 25, 27, 28, 30, 46, 63, 1, 2, 17, 25, 31, 56, 60, 61, 63, 27, 42, 47, 54, 57, 0, 8, 17, 33, 48, 55, 1, 12, 13, 32, 13, 22, 31, 41, 47, 49, 53, 61, 8, 10, 24, 28, 33, 52, 57, 58, 13, 16, 18, 28, 30, 46, 47, 50, 55, 56, 15, 17, 18, 20, 23, 25, 47, 55, 0, 4, 9, 11, 31, 38, 56, 25, 57, 61, 6, 28, 39, 61, 23, 24, 28, 30, 38, 44, 47, 52, 2, 18, 19, 20, 24, 29, 32, 36, 39, 46, 55, 59, 61, 2, 16, 23, 9, 12, 29, 46, 51, 54, 60, 61, 8, 19, 31, 6, 28, 47, 56, 22, 36, 39, 43, 59, 23, 5, 8, 19, 24, 48, 49, 51, 52, 60, 3, 6, 14, 16, 19, 34, 35, 39, 51, 56, 2, 14, 15, 17, 26, 36, 41, 55, 59, 3, 12, 19, 20, 22, 54, 17, 24, 32, 39, 46, 51, 63, 3, 26, 40, 46, 48, 59, 39, 50, 25, 45, 1, 7, 9, 17, 19, 20, 22, 30, 31, 2, 19, 27, 39, 44, 45, 55, 58, 0, 2, 29, 32, 49, 56]
RES_VAL_Q = [-80, 99, -89, -117, -110, -33, -37, 71, 56, 72, -2, -20, -31, -53, -60, -87, -22, -69, 113, 58, -42, 32, -24, 90, 102, 51, 124, -67, -33, 120, -67, -100, 40, -41, 115, 67, 40, -109, 55, 20, 28, -92, -48, 59, -53, -46, -70, 106, -52, 70, -99, -94, -37, -30, 66, 13, -6, 60, 115, 47, -54, -81, -41, -45, 40, -81, -124, -28, -76, 112, 121, 41, -57, -13, -86, -8, -85, 48, -34, 56, 31, -82, -126, 119, 15, -106, 96, -97, 39, -26, 107, 106, 51, -95, 41, -3, 22, 72, 14, -48, 13, -58, -111, -124, -35, 78, -61, 31, 3, 1, -52, -26, 125, -83, -67, -76, 114, 46, 82, 36, -71, 93, 62, -34, -11, 65, -91, 84, -91, -112, -18, -123, 125, -18, 2, 110, 46, 65, -23, 95, -7, -124, -118, -95, 93, -97, -28, -47, 126, -6, -62, -64, 5, 32, -92, -6, -1, -81, -71, 36, 93, 57, -118, 107, -5, 10, -26, 87, -4, 91, -48, 84, -23, 63, 30, 105, -106, 47, -49, -48, -11, 67, 14, -28, -87, -5, 12, -86, 23, 122, 5, -116, -69, -72, 21, -43, -66, 68, 23, 46, 38, -57, 26, -116, -57, -99, -56, -95, -33, 11, -120, -117, -51, 52, 64, 107, -53, -82, 34, -36, -20, 120, -113, 62, 85, 12, -87, -26, 72, -72, -4, 79, 19, -93, -127, 119, 57, -116, -101, 81, 12, -28, 64, -13, -124, 68, -94, -102, -81, 94, 54, -103, -49, -66, -87, -9, -113, 19, 27, -97, 8, 42, 123, 67, 68, 120, -78, 21, -83, -94, 108, -4, -77, -114, -123, -90, 109, 7, 7, -8, 107, -72, 91, 25, -82, -21, 25, -81, 121, -34, -17, 4, 84, -83, 23, -56, -70, -21, -38, -38, -114, -109, -121, 47, 105, -53, -21, -78, 44, -33, -107, 43, -91, 4, 75, 52, 53, -88, -18, -120, -36, 86, 23, -68, -2, -101, 84, -30, 45, -33, 6, 123, 42, -53, 25, -62, 56, 33, -59, 125, -10, 104, 3, -120, -73, 29, -99, -92, 95, -24, -109, -21, 9, 91, -101, -68, 33, -110, -113, -105, 127, -72, -50, 1, 47, 113, -7, 116, -47, -55, -125, -31, 81, -72, 85, -83, -96, 26, 41, 108, 76, 64, 106, 43, -103, -34, -30, -11, 92, 53, 101, 25, 126, 14, 114, -88, -79, -41, -89, 118, 89, -34, 52, -33, 88, -22, -101, 53, -105, -25, 22, -26, 88, -105, 94, -95]
RES_SCALE = 0.004304171547176331
IN_VAL_Q = [-115, -72, -82, 81, 109, -58, 101, 3, -66, -74, 62, 34, -69, 77, 5, -86, -1, 21, -125, -7, 59, 32, 108, 94, 95, 60, -57, 94, -52, 7, 22, -68, 68, -48, -125, -121, -8, -96, -63, -31, 20, -19, 30, -60, 80, 67, 17, -16, -123, -8, 32, -17, -4, 5, 20, -111, -3, 63, -18, -51, 66, -109, -3, 88, 116, -47, -42, 81, 77, -70, -94, -20, 96, -83, -121, -18, 93, -88, 36, 111, -62, -91, 62, -53, -70, -33, -44, 12, 65, -53, 11, 46, 49, -92, -10, 6, -83, 1, 41, -73, 118, 58, 124, -127, -61, -108, 92, -92, 74, 102, -10, -48, -125, -39, -61, 39, 110, -76, 109, 115, 103, -54, -96, 67, -106, 68, -21, -92, 39, -27, 79, -11, 73, 30, 119, -73, 11, -66, 66, -61, -48, -26, -15, 109, 93, -8, -74, -109, -94, -60, -70, -20, -11, -83, -60, 91, -33, -10, -43, 48, 61, -47, 54, -16, 108, -122, 58, 126, 117, -87, -74, -24, 103, 122, 51, 33, 93, 16, 80, 71, 124, -122, -102, 21, -18, -113, -28, 2, 66, 84, 10, -37]
IN_SCALE = 0.006192174483471968
W_OUT_Q = [[-26, 11, 6, -16, -40, 6, 25, -26, 12, -2, -20, -19, 15, -14, -24, 34, -12, -87, -3, 9, -9, 26, -9, -8, -2, -8, -44, -29, -10, -20, 37, -32, -16, 6, -20, 25, -6, 5, 3, -1, -9, 11, 4, 17, 1, 9, -2, 15, -26, 31, 45, -12, 70, 12, -3, -24, -1, 22, -9, -11, 14, 0, 59, -21, -1], [53, 47, -16, 18, -45, -21, -34, -20, -33, 14, -106, -38, 8, -73, 36, 64, -39, 81, -25, -5, -27, -47, 30, -56, 21, 6, -34, 2, 83, 69, 84, 104, -38, 23, 2, -50, 8, 67, 40, 41, 59, -13, 116, 32, -9, -1, -60, -33, -75, -24, -71, -49, -29, -51, 17, 13, -10, -49, 30, -26, 26, -7, -64, -5, -69], [-27, -58, 10, -1, 86, 15, 9, 45, 22, -12, 125, 57, -23, 87, -12, -98, 51, 5, 27, -4, 36, 21, -21, 64, -19, 2, 78, 27, -73, -49, -121, -72, 54, -28, 19, 24, -2, -72, -43, -40, -49, 2, -120, -49, 7, -8, 62, 18, 102, -7, 26, 62, -40, 38, -14, 10, 11, 26, -21, 37, -41, 8, 5, 26, 127]]
W_OUT_SCALE = 0.01774476456829882
B_RES_Q = [47, -83, 82, 83, 109, -69, -81, 107, -72, 76, -110, -83, -1, -127, 86, 0, -27, 114, -23, 28, -126, -50, 102, 40, -89, 15, -36, 48, -66, 29, 118, -89, -58, -69, -119, 107, -82, -118, 41, -9, -93, -98, -67, -11, 49, 13, -107, 125, 74, -111, 71, -49, 126, -34, -91, -23, -9, -41, 3, -100, 68, -89, -56, -3]
B_RES_SCALE = 0.006259135843261959
LEAK = 0.5
ADD_BIAS = True
MEAN = [-0.015935584902763367, -0.020882615819573402, -1.027826189994812]
SCALE = [0.29528293013572693, 0.13869880139827728, 0.30722180008888245]
CLASSES = [0, 1, 2]
# =========================================================

# ----------------------------
# 推論設定（完全オンライン用）
# ----------------------------
SAMPLE_MS = 10
WARMUP_FRAMES = 20
EMA_BETA = 0.20
DEBOUNCE = 3
MARGIN = 0.0

# ----------------------------
# 標準化（PC側 MEAN/SCALE と一致させる）
# ----------------------------
def standardize_vec(u):
    if MEAN is None or SCALE is None:
        return u[:]
    out = [0.0] * K
    for i in range(K):
        s = SCALE[i] if SCALE[i] != 0 else 1.0
        out[i] = (u[i] - MEAN[i]) / s
    return out

# ----------------------------
# ESN 1 step（CSR + int8）
# x: (N,) state
# u: (K,) standardized input
# ----------------------------
def esn_step_inplace(x, u):
    pre = [0.0] * N
    for i in range(N):
        s = 0.0

        # Reservoir W*x (CSR)
        start = RES_ROW_PTR[i]
        end   = RES_ROW_PTR[i + 1]
        for p in range(start, end):
            j = RES_COL_IDX[p]
            s += (RES_VAL_Q[p] * RES_SCALE) * x[j]

        # Input Win*u (dense int8, row-major flat)
        base = i * K
        for kk in range(K):
            s += (IN_VAL_Q[base + kk] * IN_SCALE) * u[kk]

        # Bias (int8 + scale)
        s += (B_RES_Q[i] * B_RES_SCALE)

        pre[i] = s

    # tanh + leak
    if LEAK == 1.0:
        for i in range(N):
            x[i] = _tanh(pre[i])
    else:
        for i in range(N):
            xn = _tanh(pre[i])
            x[i] = (1.0 - LEAK) * x[i] + LEAK * xn

# ----------------------------
# 1フレーム推論（完全オンライン）
# scores: (M,)
# ----------------------------
def linear_scores_from_state(x):
    scores = [0.0] * M
    for m in range(M):
        row_q = W_OUT_Q[m]  # length N (+bias at N)
        s = 0.0
        for i in range(N):
            s += (row_q[i] * W_OUT_SCALE) * x[i]
        if ADD_BIAS:
            s += (row_q[N] * W_OUT_SCALE)
        scores[m] = s
    return scores

def argmax_and_margin(scores):
    best = 0
    bestv = scores[0]
    secondv = -1e30
    for i in range(M):
        v = scores[i]
        if v > bestv:
            secondv = bestv
            bestv = v
            best = i
        elif v > secondv:
            secondv = v
    return best, (bestv - secondv)

# ----------------------------
# 表示
# ----------------------------
def show_label(lbl):
    try:
        n = int(lbl)
    except:
        n = 0
    if n == 0:
        microbit.display.show('0')
    elif n == 1:
        microbit.display.show('1')
    elif n == 2:
        microbit.display.show('2')
    else:
        microbit.display.show('?')

# =========================================================
# 短音刻みメロディ（ノンブロッキング）
#  - 0: 無音
#  - 1: 歓喜の歌
#  - 2: ハッピーバースデートゥーユー
# ※「本家のmusic.ODE/music.NYANをそのまま再生」だとブロックしがちなので、
#   pitch(wait=False)で刻む方式にしています。
# =========================================================
# (Hz, ms) で並べる。freq=0 は休符。
MELODY_ODE = [
    (330,150),(330,150),(349,150),(392,150), # ミミファソ
    (392,150),(349,150),(330,150),(294,150), # ソファミレ
    (262,150),(262,150),(294,150),(330,150), # ドドレミ
    (330,200),(294,200),(294,250),(0,120),   # ミレレ-(休)
    (330,150),(330,150),(349,150),(392,150), # ミミファソ
    (392,150),(349,150),(330,150),(294,150), # ソファミレ
    (262,150),(262,150),(294,150),(330,150), # ドドレミ
    (294,200),(262,200),(262,250),(0,120),   # レドド-(休)
]
MELODY_HAPPY = [
    # --- フレーズ 1: ソ(低) ソ(低) ラ(低) ソ(低) ド(中) シ(低) ---
    (392,150),(392,200),(440,300),(392,300),(523,300),(494,450),(0,120),

    # --- フレーズ 2: ソ(低) ソ(低) ラ(低) ソ(低) レ(中) ド(中) ---
    (392,150),(392,200),(440,300),(392,300),(587,300),(523,450),(0,120),

    # --- フレーズ 3: ソ(低) ソ(低) ソ(高) ミ(中) ド(中) シ(低) ラ(低) ---
    (392,150),(392,200),(784,300),(659,300),(523,300),(494,300),(440,450),(0,120),

    # --- フレーズ 4: ファ(中) ファ(中) ミ(中) ド(中) レ(中) ド(中) ---
    (698,150),(698,200),(659,300),(523,300),(587,300),(523,500),
]

_cur_melody = None
_mel_idx = 0
_next_note_ms = 0

def _set_melody_for_label(lbl):
    global _cur_melody, _mel_idx, _next_note_ms
    try:
        n = int(lbl)
    except:
        n = 0

    music.stop()  # 切替時は必ず停止

    if n == 1:
        _cur_melody = MELODY_ODE
        _mel_idx = 0
        _next_note_ms = 0
    elif n == 2:
        _cur_melody = MELODY_HAPPY
        _mel_idx = 0
        _next_note_ms = 0

    else:
        # 0（無音）
        _cur_melody = None
        _mel_idx = 0
        _next_note_ms = 0

def _music_tick():
    #毎ループ呼ぶ。時間が来たら次の短音を鳴らす（ノンブロッキング）
    global _mel_idx, _next_note_ms

    if _cur_melody is None:
        return

    now = microbit.running_time()
    if now < _next_note_ms:
        return

    freq, dur = _cur_melody[_mel_idx]
    if freq <= 0:
        music.stop()
    else:
        # wait=False で推論ループを止めない
        music.pitch(int(freq), int(dur), wait=False)

    _next_note_ms = now + int(dur)
    _mel_idx += 1
    if _mel_idx >= len(_cur_melody):
        _mel_idx = 0  # ループ再生（不要ならここで _cur_melody=None にして終了）


# =========================================================
# main loop（完全オンライン）
# =========================================================
x_state = [0.0] * N

# EMAの状態
z_ema = None

# debounce状態
last_shown = None
cand = None
cand_count = 0

microbit.display.show('?')

frame = 0
while True:
    ax = microbit.accelerometer.get_x() * MG2G
    ay = microbit.accelerometer.get_y() * MG2G
    az = microbit.accelerometer.get_z() * MG2G

    u_std = standardize_vec([ax, ay, az])

    # state update
    esn_step_inplace(x_state, u_std)

    # warmup中は表示しない
    frame += 1
    if frame < WARMUP_FRAMES:
        microbit.sleep(SAMPLE_MS)
        continue

    # scores
    z = linear_scores_from_state(x_state)

    # EMA
    if z_ema is None:
        z_ema = z[:]
    else:
        b = EMA_BETA
        for i in range(M):
            z_ema[i] = (1.0 - b) * z_ema[i] + b * z[i]

    # predict with margin
    pred, gap = argmax_and_margin(z_ema)

    # マージンが小さい場合は切替抑制（last_shown維持）
    if MARGIN > 0.0 and last_shown is not None and gap < MARGIN:
        pred = last_shown

    # debounce
    if cand is None:
        cand = pred
        cand_count = 1
    else:
        if pred == cand:
            cand_count += 1
        else:
            cand = pred
            cand_count = 1

    if cand_count >= DEBOUNCE:
        # class index -> label
        try:
            out_label = CLASSES[cand]
        except:
            out_label = cand

        if out_label != last_shown:
            show_label(out_label)
            _set_melody_for_label(out_label)  # 0/1/2で切替
            last_shown = out_label

    _music_tick()  # 毎ループ刻む
    microbit.sleep(SAMPLE_MS)